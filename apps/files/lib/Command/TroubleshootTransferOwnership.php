<?php
/**
 * @author Piotr Mrowczynski <piotr@owncloud.com>
 *
 * @copyright Copyright (c) 2020, ownCloud GmbH
 * @license AGPL-3.0
 *
 * This code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License, version 3,
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

namespace OCA\Files\Command;

use Doctrine\DBAL\Platforms\MySqlPlatform;
use OCP\IDBConnection;
use OCP\Share\IManager;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

/**
 */
class TroubleshootTransferOwnership extends Command {

	/**
	 * @var IManager
	 */
	protected $shareManager;

	/**
	 * @var IDBConnection
	 */
	protected $connection;

	private $allowedOps = "all|invalid-owner|invalid-initiator";

	public function __construct(IDBConnection $connection) {
		$this->connection = $connection;
		parent::__construct();
	}

	protected function configure() {
		$this
			->setName('files:troubleshoot-transfer-ownership')
			->setDescription('Scan for problems that might have occurred while running ownership transfer')
			->addArgument(
				'type',
				InputArgument::OPTIONAL,
				$this->allowedOps,
				'all'
			);
	}

	public function execute(InputInterface $input, OutputInterface $output) {
		$type = $input->getArgument('type');
		if ($type == 'all' || $type == 'invalid-initiator') {
			$this->findInvalidReshareInitiator($input, $output);
		}
		if ($type == 'all' || $type == 'invalid-owner') {
			$this->findInvalidShareOwner($input, $output);
		}
	}

	/**
	 * Search for shares with invalid storage ids. This could have happened due
	 * to past bug or as a result of lack of transactions in IManager->transferShare
	 * that could cause mismatching entries when a run has been terminated.
	 *
	 * @param InputInterface $input
	 * @param OutputInterface $output
	 */
	private function findInvalidShareOwner(InputInterface $input, OutputInterface $output) {
		$output->writeln("SEARCHING FOR SHARES THAT HAVE INVALID UID_OWNER - UID_OWNER VALUES THAT HAVE NOT BEEN UPDATED TO MATCH REQUIRED TRANSFERRED STORAGE");

		$invalidSharesCount = 0;
		$invalidSharesFound = false;

		$shareStorages = \array_merge(
			$this->getAllInvalidShareStorages('home::'),
			$this->getAllInvalidShareStorages('object::user:')
		);
		foreach ($shareStorages as $shareStorage) {
			if (!$invalidSharesFound) {
				$output->writeln("Invalid shares:");
			}
			$invalidSharesCount += 1;
			$output->writeln("id=${shareStorage['id']},file_source=${shareStorage['file_source']},storage=${shareStorage['storage']},uid_owner=${shareStorage['uid_owner']},uid_initiator=${shareStorage['uid_initiator']},share_with=${shareStorage['share_with']}");
		}

		$output->writeln("FOUND $invalidSharesCount INVALID SHARE OWNERS");
		$output->writeln("");
	}

	/**
	 * Search for invalid initiator of the reshare that has been generated by
	 * bug which has been fixed as of https://github.com/owncloud/core/pull/37791
	 *
	 * NOTE: this command can take long
	 *
	 * @param InputInterface $input
	 * @param OutputInterface $output
	 */
	private function findInvalidReshareInitiator(InputInterface $input, OutputInterface $output) {
		$output->writeln("SEARCHING FOR RESHARES THAT HAVE INVALID UID_INITIATOR(RESHARER) - RESHARER WHICH DOES NOT HAVE HIS SHARE MOUNTED ANY MORE AND THUS SHARE IS CORRUPTED");
		$invalidReshareInitiatorCount = 0;
		$resharers = $this->getAllResharers();

		foreach ($resharers as $resharer) {
			$invalidReshareInitiatorFound = false;
			$resharerUid = $resharer['uid_initiator'];

			// setup user fs
			//$this->setupFS($resharerUid);
			$userFolder = \OC::$server->getUserFolder($resharerUid);

			// extract all reshares for this user and check if they have mount node
			$reshares = $this->getReshares($resharerUid);
			foreach ($reshares as $reshare) {
				$nodes = $userFolder->getById((int) $reshare['file_source'], true);
				if (\count($nodes) == 0) {
					if (!$invalidReshareInitiatorFound) {
						$output->writeln("Invalid reshare initiator found for user $resharerUid in shares: ");
					}
					$invalidReshareInitiatorFound = true;
					$invalidReshareInitiatorCount += 1;
					$output->writeln("id=${reshare['id']},file_source=${reshare['file_source']},uid_owner=${reshare['uid_owner']},uid_initiator=${reshare['uid_initiator']},share_with=${reshare['share_with']}");
				}
			}
		}
		$output->writeln("FOUND $invalidReshareInitiatorCount INVALID INITIATOR RESHARES");
		$output->writeln("");
	}

	private function getAllResharers() {
		$query = $this->connection->getQueryBuilder();

		$query->selectDistinct('uid_initiator')
			->from('share')
			->andWhere($query->expr()->orX(
				$query->expr()->eq('item_type', $query->createNamedParameter('file')),
				$query->expr()->eq('item_type', $query->createNamedParameter('folder'))
			));

		$query->andWhere($query->expr()->neq('uid_initiator', 'uid_owner'));

		$cursor = $query->execute();
		$resharers = $cursor->fetchAll();
		$cursor->closeCursor();

		return $resharers;
	}

	private function getReshares($userId) {
		$query = $this->connection->getQueryBuilder();

		$query->select('*')
			->from('share')
			->andWhere($query->expr()->orX(
				$query->expr()->eq('item_type', $query->createNamedParameter('file')),
				$query->expr()->eq('item_type', $query->createNamedParameter('folder'))
			));

		$query->andWhere($query->expr()->neq('uid_initiator', 'uid_owner'));
		$query->andWhere($query->expr()->eq('uid_initiator', $query->createNamedParameter($userId)));

		$cursor = $query->execute();
		$reshares = $cursor->fetchAll();
		$cursor->closeCursor();

		return $reshares;
	}

	private function getAllInvalidShareStorages($storageType) {
		$query = $this->connection->getQueryBuilder();

		if ($this->connection->getDatabasePlatform() instanceof MySqlPlatform) {
			$concatFunction = $query->createFunction("CONCAT('$storageType', s.uid_owner)");
		} else {
			$concatFunction = $query->createFunction("('$storageType' || s.`uid_owner`)");
		}

		$query->select('s.id', 's.file_source', 'st.id', 's.uid_owner', 's.uid_initiator', 's.share_with')
			->selectAlias('s.id', 'id')
			->selectAlias('s.file_source', 'file_source')
			->selectAlias('st.id', 'storage')
			->selectAlias('s.uid_owner', 'uid_owner')
			->selectAlias('s.uid_initiator', 'uid_initiator')
			->selectAlias('s.share_with', 'share_with')
			->from('share', 's')
			->join('s', 'filecache', 'f', $query->expr()->eq('s.file_source', 'f.fileid'))
			->join('f', 'storages', 'st', $query->expr()->eq('st.numeric_id', 'f.storage'))
			->andWhere($query->expr()->orX(
				$query->expr()->like('st.id', $query->createNamedParameter("$storageType%"))
			))
			->andWhere($query->expr()->orX(
				$query->expr()->eq('s.item_type', $query->createNamedParameter('file')),
				$query->expr()->eq('s.item_type', $query->createNamedParameter('folder'))
			))
			->andWhere($query->expr()->neq(
				$concatFunction,
				'st.id'
			));

		$cursor = $query->execute();
		$shareStorages = $cursor->fetchAll();
		$cursor->closeCursor();

		return $shareStorages;
	}
}
